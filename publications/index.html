<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">

  <title>Valerio Terragni | publications</title>
  <meta name="description" content="">

  

  <link rel="shortcut icon" href="/assets/img/favicon.ico">

  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="canonical" href="/publications/">
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    
    <span class="site-title">
        
        <a class="page-link" href="/">Dr. Valerio <strong>Terragni</strong></a>
    </span>
    

    <nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"></path>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"></path>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

      <div class="trigger">
        <!-- About -->
        <a class="page-link" href="/">about</a>

        <!-- Blog -->
        <!--<a class="page-link" href="/blog/">blog</a>-->

        <!-- Pages -->
        
          
        
          
        
          
        
          
            <a class="page-link" href="/publications/">publications</a>
          
        
          
            <a class="page-link" href="/service/">service and awards</a>
          
        
          
        
          
        

        <!-- CV link -->
        <!-- <a class="page-link" href="/assets/pdf/CV.pdf">vitae</a> -->

      </div>
    </nav>

  </div>

</header>



    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">publications</h1>
    <h5 class="post-description">Publications by categories in reversed chronological order. Generated by jekyll-scholar. See my <a href="http://dblp.uni-trier.de/pers/hd/t/Terragni:Valerio" title="dblp profile">DBLP profile</a>
</h5>
  </header>

  <article class="post-content publications clearfix">
    
<h3 class="year">2025</h3>
<ol class="bibliography">
<li>
<span class="fa-li"><i>AIST 2025</i></span>



<div id="Ruberto2025FromImplemented">
  
      
    <span class="title">From Implemented to Expected Behaviors: Leveraging Regression Oracles for Non-Regression Fault Detection Using LLMs</span>
    
    <span class="author">
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              
               
                  Judith Perera,
              
              
            
          
        
      
        
          
            
              
               
                  Gunel Jahangirova,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the IEEE Conference on Software Testing, Verification and Validation Workshop</em>
    
    

    
    
    <em>, 2025</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
  
  
  
  
  

      
  
      
  </span>

  <!-- Hidden abstract block -->
  
  <span class="bibtex hidden2">
    <p>@inproceedings{Ruberto2025FromImplemented,
  author = {Ruberto, Stefano and Perera, Judith and Jahangirova, Gunel and Terragni, Valerio},
  title = {From Implemented to Expected Behaviors: Leveraging Regression Oracles for Non-Regression Fault Detection Using LLMs},
  booktitle = {IEEE Conference on Software Testing, Verification and Validation Workshop},
  year = {2025},
  publisher = {IEEE}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICST 2025</i></span>



<div id="Dietrich2025CrossBuild">
  
      
    <span class="title">Towards Cross-Build Differential Testing</span>
    
    <span class="author">
      
        
          
            
              
               
                  Jens Dietrich,
              
              
            
          
        
      
        
          
            
              
               
                  Tim White,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Behnaz Hassanshahi
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the IEEE Conference on Software Testing, Verification and Validation</em>
    
    

    
    
    <em>, 2025</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/dietrich-icst-2025.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Recent concerns about software supply chain security
have led to the emergence of different binaries built from the
same source code. This will sometimes result in binaries that are
not identical and therefore have different cryptographic hashes.
The question arises whether those binaries are still equivalent,
i.e., whether they have the same behaviour. We explore whether
differential testing can be used to provide evidence for nonequivalence.
We study this for 3,541 pairs of binaries built for the same
Maven artifact version, distributed on Maven Central, Google
Assured Open Source Software and/or Oracle Build-From-Source.
We use EVOSUITE to generate tests for the baseline binary from
Maven Central, run these tests against this baseline binary and
any available alternately built binaries, and compare the results for
consistency. We argue that any differences may indicate variations
in program behaviour and could, therefore, be used to detect
compromised binaries or failures at runtime.
Although our preliminary experiments did not reveal any
compromised builds, our approach successfully identified three
build configuration errors that caused changes in runtime
behaviour. These findings underscore the potential of our method
to uncover subtle build differences, highlighting opportunities for
improvement.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{Dietrich2025CrossBuild,
  author = {Dietrich, Jens and White, Tim and Terragni, Valerio and Hassanshahi, Behnaz},
  title = {Towards Cross-Build Differential Testing},
  booktitle = {IEEE Conference on Software Testing, Verification and Validation},
  year = {2025},
  publisher = {IEEE}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICST 2025</i></span>



<div id="Terragni2025SystemLevel">
  
      
    <span class="title">A System-Level Testing Framework for Automated Assessment of Programming Assignments Allowing Students Object-Oriented Design Freedom</span>
    
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Nasser Giacaman
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the IEEE Conference on Software Testing, Verification and Validation</em>
    
    

    
    
    <em>, 2025</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-icstEdu-2025.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Automated assessment of programming assignments
is essential in software engineering education, especially for large
classes where manual grading is impractical. While static analysis
can evaluate code style and syntax correctness, it cannot assess
the functional correctness of students’ implementations. Dynamic
analysis through software testing can verify program behavior
and provide automated feedback to students. However, traditional
unit and integration tests often restrict students’ design freedom
by requiring predefined interfaces and method declarations.
In this paper, we present SYSCLI, a novel testing framework
for system-level testing of JAVA-based command-Line interface
applications. SYSCLI enables test suites that evaluate the
functional correctness of students’ implementations without
limiting their design choices. We also share our experience using
SYSCLI in a second-year programming course at the University
of Auckland, which focuses on object-oriented programming
and design patterns and enrolls over 300 students each offering.
Analysis of student assignments from 2023 and 2024 shows that
SYSCLI is effective in automating grading, allows software design
flexibility, and provides actionable feedback to students. Our
experience report offers valuable insights into assessing students’
implementation of object-oriented concepts and design patterns.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{Terragni2025SystemLevel,
  author = {Terragni, Valerio and Giacaman, Nasser},
  title = {A System-Level Testing Framework for Automated Assessment of Programming Assignments Allowing Students Object-Oriented Design Freedom},
  booktitle = {IEEE Conference on Software Testing, Verification and Validation},
  year = {2025},
  publisher = {IEEE}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICST 2025</i></span>



<div id="Terragni2025Differential">
  
      
    <span class="title">Differential Testing of Concurrent Classes</span>
    
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the IEEE Conference on Software Testing, Verification and Validation</em>
    
    

    
    
    <em>, 2025</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-icst-2025.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Concurrent programs are pervasive, yet difficult
to write. The inherent complexity of thread synchronization
makes the evolution of concurrent programs prone to concurrency
faults. Previous work on regression testing concurrent programs
focused on reducing the cost of re-run the existing tests. However,
existing tests may not be able to expose the regression faults
in the modified program. In this paper, we present CONDIFF a
differential testing technique that generates concurrent tests and
oracles to expose behavioral differences between two versions of
a given concurrent class. Since concurrent programs are nondeterministic, this involves exploring all possible non-deterministic
thread interleavings of each generated test on both versions.
However, we can afford to analyze only a few concurrent tests
due to the high cost of exhaustive interleaving exploration. To
address the challenge, CONDIFF leverages the information of
code changes and trace analysis to analyze only those concurrent
tests that are likely to expose behavioral differences (if they exist).
We evaluated CONDIFF on a set of Java classes. Our results
show that CONDIFF can effectively generate concurrent tests that
expose behavioral differences.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{Terragni2025Differential,
  author = {Terragni, Valerio and Cheung, Shing-Chi},
  title = {Differential Testing of Concurrent Classes},
  booktitle = {IEEE Conference on Software Testing, Verification and Validation},
  year = {2025},
  publisher = {IEEE}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>FSE 2025</i></span>



<div id="Zhu2025MockAssertions">
  
      
    <span class="title">Understanding and Characterizing Mock Assertions in Unit Tests</span>
    
    <span class="author">
      
        
          
            
              
               
                  Hengcheng Zhu,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Lili Wei,
              
              
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung,
              
              
            
          
        
      
        
          
            
              
               
                  Jiarong Wu,
              
              
            
          
        
      
        
          
            
              
               
                  Yepang Liu
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>Proceedings of the ACM on Software Engineering</em>
     

    
    
    <em>, 2025</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/zhu-fse-2025.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Mock assertions provide developers with a powerful means to validate program behaviors that are unobservable to test assertions. Despite their significance, they are rarely considered by automated test generation techniques. Effective generation of mock assertions requires understanding how they are used in practice. Although previous studies highlighted the importance of mock assertions, none provide insight into their usages. To bridge this gap, we conducted the first empirical study on mock assertions, examining their adoption, the characteristics of the verified method invocations, and their effectiveness in fault detection. Our analysis of 4,652 test cases from 11 popular Java projects reveals that mock assertions are mostly applied to validating specific kinds of method calls, such as those interacting with external resources and those reflecting whether a certain code path was traversed in systems under test. Additionally, we find that mock assertions complement traditional test assertions by ensuring the desired side effects have been produced, validating control flow logic, and checking internal computation results. Our findings contribute to a better understanding of mock assertion usages and provide a foundation for future related research such as automated test generation that support mock assertions.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{Zhu2025MockAssertions,
  author = {Zhu, Hengcheng and Terragni, Valerio and Wei, Lili and Cheung, Shing-Chi and Wu, Jiarong and Liu, Yepang},
  title = {Understanding and Characterizing Mock Assertions in Unit Tests},
  journal = {Proceedings of the ACM on Software Engineering},
  volume = {2},
  number = {FSE},
  articleno = {FSE026},
  year = {2025}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ACM TOSEM</i></span>



<div id="terragni2025future">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3715003" target="_blank">The Future of AI-Driven Software Engineering</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Annie Vella,
              
              
            
          
        
      
        
          
            
              
               
                  Partha Roop,
              
              
            
          
        
      
        
          
            
              
               
                  Kelly Blincoe
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>ACM Trans. Softw. Eng. Methodol.</em>
     

    
    
    <em>, 2025</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-tosem-2025.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3715003" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>A paradigm shift is underway in Software Engineering, with AI systems such as LLMs playing an increasingly important role in boosting software development productivity. This trend is anticipated to persist. In the next years, we expect a growing symbiotic partnership between human software developers and AI. The Software Engineering research community cannot afford to overlook this trend; we must address the key research challenges posed by the integration of AI into the software development process. In this paper, we present our vision of the future of software development in an AI-driven world and explore the key challenges that our research community should address to realize this vision.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{terragni2025future,
  author = {Terragni, Valerio and Vella, Annie and Roop, Partha and Blincoe, Kelly},
  title = {The Future of AI-Driven Software Engineering},
  year = {2025},
  doi = {10.1145/3715003},
  journal = {ACM Trans. Softw. Eng. Methodol.},
  month = jan
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>Springer ESE</i></span>



<div id="jayasuriya2025emse">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1007/S10664-024-10563-4" target="_blank">An extended study of syntactic breaking changes in the wild</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Dhanushka Jayasuriya,
              
              
            
          
        
      
        
          
            
              
               
                  Samuel Ou,
              
              
            
          
        
      
        
          
            
              
               
                  Saakshi Hegde,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jens Dietrich,
              
              
            
          
        
      
        
          
            
              
               
                  Kelly Blincoe
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>Empirical Software Engineering</em>
     

    
    <em>, pages 42</em>
    
    
    <em>, 2025</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/jayasuriya-ese-2025.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1007/S10664-024-10563-4" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Libraries assist in accelerating the development of software applications by providing reusable functionalities. Libraries and applications that declare these libraries as dependencies become their clients. However, as libraries evolve, maintaining the dependencies in client projects can be challenging if the new version contains breaking changes. Yet, limited research focuses on analyzing the impact of breaking changes on client projects when updating dependencies in the wild. Hence, we conduct an empirical analysis using Java projects built using Maven to investigate the impact of breaking changes introduced between two library versions. Our dataset included 18,415 Maven artifacts, declaring 142,355 direct dependencies, out of which 71.60% were not up-to-date. We automatically updated these dependencies and discovered that 11.58% of the dependency updates resulted in breaking changes that affected the client, and almost half of them were introduced during a non-major update. We analyzed the changes in the libraries that contributed towards these breaking changes, and our results indicate that changes in transitive dependencies were a significant factor in introducing breaking changes. We further investigated if it was common for clients to use functionalities of transitive dependencies directly without declaring them. This showed that over half of the clients use transitive functionality. Therefore, we analyzed actions suggested to resolve these breaking changes introduced by transitive dependencies under the discussions on open-source platforms, and the frequently suggested action was to exclude the transitive dependency from the project configuration.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{jayasuriya2025emse,
  author = {Jayasuriya, Dhanushka and Ou, Samuel and Hegde, Saakshi and Terragni, Valerio and Dietrich, Jens and Blincoe, Kelly},
  title = {An extended study of syntactic breaking changes in the wild},
  journal = {Empirical Software Engineering},
  volume = {30},
  number = {2},
  pages = {42},
  year = {2025},
  doi = {10.1007/S10664-024-10563-4}
}
</p>
  </span>
</div>
</li>
</ol>

<h3 class="year">2024</h3>
<ol class="bibliography">
<li>
<span class="fa-li"><i>Springer ESE</i></span>



<div id="khaliliESE2024">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1007/S10664-023-10406-8" target="_blank">Semantic matching in GUI test reuse</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Farideh Khalili,
              
              
            
          
        
      
        
          
            
              
               
                  Leonardo Mariani,
              
              
            
          
        
      
        
          
            
              
               
                  Ali Mohebbi,
              
              
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>Empirical Software Engineering</em>
     

    
    <em>, pages 70</em>
    
    
    <em>, 2024</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/khalili-ese-2024.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1007/S10664-023-10406-8" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Reusing test cases across apps that share similar functionalities reduces both the effort required to produce useful test cases and the time to offer reliable apps to the market. The main approaches to reuse test cases across apps combine different semantic matching and test generation algorithms to migrate test cases across Android apps. In this paper we define a general framework to evaluate the impact and effectiveness of different choices of semantic matching with Test Reuse approaches on migrating test cases across Android apps. We offer a thorough comparative evaluation of the many possible choices for the components of test migration processes. We propose an approach that combines the most effective choices for each component of the test migration process to obtain an effective approach. We report the results of an experimental evaluation on 8,099 GUI events from 337 test configurations. The results attest the prominent impact of semantic matching on test reuse. They indicate that sentence level perform better than word level embedding techniques. They surprisingly suggest a negligible impact of the corpus of documents used for building the word embedding model for the Semantic Matching Algorithm. They provide evidence that semantic matching of events of selected types perform better than semantic matching of events of all types. They show that the effectiveness of overall Test Reuse approach depends on the characteristics of the test suites and apps. The replication package that we make publicly available online (https://star.inf.usi.ch/#/software-data/11) allows researchers and practitioners to refine the results with additional experiments and evaluate other choices for test reuse components.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{khaliliESE2024,
  author = {Khalili, Farideh and Mariani, Leonardo and Mohebbi, Ali and Pezz{\`{e}}, Mauro and Terragni, Valerio},
  title = {{Semantic matching in GUI test reuse}},
  journal = {Empirical Software Engineering},
  volume = {29},
  number = {3},
  pages = {70},
  year = {2024},
  doi = {10.1007/S10664-023-10406-8}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ASE 2024</i></span>



<div id="xu2024ase-mradopt">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3691620.3696020" target="_blank">MR-Adopt: Automatic Deduction of Input Transformation Function for Metamorphic Testing</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Congying Xu,
              
              
            
          
        
      
        
          
            
              
               
                  Songqiang Chen,
              
              
            
          
        
      
        
          
            
              
               
                  Jiarong Wu,
              
              
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Hengcheng Zhu,
              
              
            
          
        
      
        
          
            
              
               
                  Jialun Cao
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
            <em>In Proceedings of the 39th IEEE/ACM International Conference on Automated Software Engineering</em>

    

    
    <em>, pages 557-569</em>
    
    
    <em>, 2024</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/xu-ase-2024.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3691620.3696020" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>While a recent study reveals that many developer-written test cases can encode a reusable Metamorphic Relation (MR), over 70% of them directly hard-code the source input and follow-up input in the encoded relation. Such encoded MRs, which do not contain an explicit input transformation to transform the source inputs to corresponding follow-up inputs, cannot be reused with new source inputs to enhance test adequacy.In this paper, we propose MR-Adopt (Automatic Deduction Of inPut Transformation) to automatically deduce the input transformation from the hard-coded source and follow-up inputs, aiming to enable the encoded MRs to be reused with new source inputs. With typically only one pair of source and follow-up inputs available in an MR-encoded test case as the example, we leveraged LLMs to understand the intention of the test case and generate additional examples of source-followup input pairs. This helps to guide the generation of input transformations generalizable to multiple source inputs. Besides, to mitigate the issue that LLMs generate erroneous code, we refine LLM-generated transformations by removing MR-irrelevant code elements with data-flow analysis. Finally, we assess candidate transformations based on encoded output relations and select the best transformation as the result. Evaluation results show that MR-Adopt can generate input transformations applicable to all experimental source inputs for 72.00% of encoded MRs, which is 33.33% more than using vanilla GPT-3.5. By incorporating MR-Adopt-generated input transformations, encoded MR-based test cases can effectively enhance the test adequacy, increasing the line coverage and mutation score by 10.62% and 18.91%, respectively.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{xu2024ase-mradopt,
  author = {Xu, Congying and Chen, Songqiang and Wu, Jiarong and Cheung, Shing-Chi and Terragni, Valerio and Zhu, Hengcheng and Cao, Jialun},
  title = {MR-Adopt: Automatic Deduction of Input Transformation Function for Metamorphic Testing},
  year = {2024},
  doi = {10.1145/3691620.3696020},
  booktitle = {Proceedings of the 39th IEEE/ACM International Conference on Automated Software Engineering},
  pages = {557-569}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>arXiv 2024</i></span>



<div id="cho2024automated">
  
      
    <span class="title">Automated Trustworthiness Testing for Machine Learning Classifiers</span>
    
    <span class="author">
      
        
          
            
              
               
                  Steven Cho,
              
              
            
          
        
      
        
          
            
              
               
                  Seaton Cousins-Baxter,
              
              
            
          
        
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>arXiv</em>
     

    
    
    <em>, 2024</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/cho-tower-2024.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Machine Learning (ML) has become an integral part of our society, commonly used in critical domains such as finance, healthcare, and transportation. Therefore, it is crucial to evaluate not only whether ML models make correct predictions but also whether they do so for the correct reasons, ensuring our trust that will perform well on unseen data. This concept is known as trustworthiness in ML. Recently, explainable techniques (e.g., LIME, SHAP) have been developed to interpret the decision-making processes of ML models, providing explanations for their predictions (e.g., words in the input that influenced the prediction the most). Assessing the plausibility of these explanations can enhance our confidence in the models’ trustworthiness. However, current approaches typically rely on human judgment to determine the plausibility of these explanations. This paper proposes TOWER, the first technique to automatically create trustworthiness oracles that determine whether text classifier predictions are trustworthy. It leverages word embeddings to automatically evaluate the trustworthiness of a model-agnostic text classifiers based on the outputs of explanatory techniques. Our hypothesis is that a prediction is trustworthy if the words in its explanation are semantically related to the predicted class. We perform unsupervised learning with untrustworthy models obtained from noisy data to find the optimal configuration of TOWER. We then evaluated TOWER on a human-labeled trustworthiness dataset that we created. The results show that TOWER can detect a decrease in trustworthiness as noise increases, but is not effective when evaluated against the human-labeled dataset. Our initial experiments suggest that our hypothesis is valid and promising, but further research is needed to better understand the relationship between explanations and trustworthiness issues.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{cho2024automated,
  title = {Automated Trustworthiness Testing for Machine Learning Classifiers},
  author = {Cho, Steven and Cousins-Baxter, Seaton and Ruberto, Stefano and Terragni, Valerio},
  year = {2024},
  url = {https://arxiv.org/abs/2406.05251},
  journal = {arXiv},
  eprint = {2406.05251},
  archiveprefix = {arXiv}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ACM TOSEM</i></span>



<div id="xu-tosem-2024">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3656340" target="_blank">MR-Scout: Automated Synthesis of Metamorphic Relations from Existing Test Cases</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Congying Xu,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Hengcheng Zhu,
              
              
            
          
        
      
        
          
            
              
               
                  Jiarong Wu,
              
              
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>ACM Transaction on Software Engineering and Methodology</em>
     

    
    
    <em>, 2024</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/xu-tosem-2024.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3656340" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Metamorphic Testing (MT) alleviates the oracle problem by defining oracles based on metamorphic relations (MRs), that govern multiple related inputs and their outputs. However, designing MRs is challenging, as it requires domain-specific knowledge. This hinders the widespread adoption of MT. We observe that developer-written test cases can embed domain knowledge that encodes MRs. Such encoded MRs could be synthesized for testing not only their original programs but also other programs that share similar functionalities. In this paper, we propose MR-Scout to automatically synthesize MRs from test cases in open-source software (OSS) projects. MR-Scout first discovers MR-encoded test cases (MTCs), and then synthesizes the encoded MRs into parameterized methods (called codified MRs), and filters out MRs that demonstrate poor quality for new test case generation. MR-Scout discovered over 11,000 MTCs from 701 OSS projects. Experimental results show that over 97% of codified MRs are of high quality for automated test case generation, demonstrating the practical applicability of MR-Scout. Furthermore, codified-MRs-based tests effectively enhance the test adequacy of programs with developer-written tests, leading to 13.52% and 9.42% increases in line coverage and mutation score, respectively. Our qualitative study shows that 55.76% to 76.92% of codified MRs are easily comprehensible for developers.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{xu-tosem-2024,
  author = {Xu, Congying and Terragni, Valerio and Zhu, Hengcheng and Wu, Jiarong and Cheung, Shing-Chi},
  title = {{MR-Scout: Automated Synthesis of Metamorphic Relations from Existing Test Cases}},
  year = {2024},
  publisher = {ACM},
  doi = {10.1145/3656340},
  journal = {ACM Transaction on Software Engineering and Methodology},
  volume = {33},
  number = {6}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ACM TOSEM</i></span>



<div id="zhu-tosem-2024">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3617171" target="_blank">StubCoder: Automated Generation and Repair of Stub Code for Mock Objects</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Hengcheng Zhu,
              
              
            
          
        
      
        
          
            
              
               
                  Lili Wei,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Yepang Liu,
              
              
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung,
              
              
            
          
        
      
        
          
            
              
               
                  Jiarong Wu,
              
              
            
          
        
      
        
          
            
              
               
                  Qin Sheng,
              
              
            
          
        
      
        
          
            
              
               
                  Bing Zhang,
              
              
            
          
        
      
        
          
            
              
               
                  Lihong Song
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>ACM Transaction on Software Engineering and Methodology</em>
     

    
    <em>, pages 16:1–16:31</em>
    
    
    <em>, 2024</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/zhu-tosem-2024.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3617171" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Mocking is an essential unit testing technique for isolating the class under test from its dependencies. Developers often leverage mocking frameworks to develop stub code that specifies the behaviors of mock objects. However, developing and maintaining stub code is labor-intensive and error-prone. In this article, we present StubCoder to automatically generate and repair stub code for regression testing. StubCoder implements a novel evolutionary algorithm that synthesizes test-passing stub code guided by the runtime behavior of test cases. We evaluated our proposed approach on 59 test cases from 13 open source projects. Our evaluation results show that StubCoder can effectively generate stub code for incomplete test cases without stub code and repair obsolete test cases with broken stub code.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{zhu-tosem-2024,
  author = {Zhu, Hengcheng and Wei, Lili and Terragni, Valerio and Liu, Yepang and Cheung, Shing-Chi and Wu, Jiarong and Sheng, Qin and Zhang, Bing and Song, Lihong},
  title = {{StubCoder: Automated Generation and Repair of Stub Code for Mock Objects}},
  year = {2024},
  volume = {33},
  number = {1},
  publisher = {ACM},
  pages = {16:1--16:31},
  doi = {10.1145/3617171},
  journal = {ACM Transaction on Software Engineering and Methodology},
  month = nov,
  articleno = {16},
  numpages = {31}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>IEEE TSE</i></span>



<div id="ayerdi-genmorph-tse-2024">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/TSE.2024.3407840" target="_blank">GenMorph: Automatically Generating Metamorphic Relations via Genetic Programming</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Jon Ayerdi,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Gunel Jahangirova,
              
              
            
          
        
      
        
          
            
              
               
                  Aitor Arrieta,
              
              
            
          
        
      
        
          
            
              
               
                  Paolo Tonella
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>IEEE Transactions on Software Engineering</em>
     

    
    <em>, pages 1888-1900</em>
    
    
    <em>, 2024</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ayerdi-tse-2024.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1109/TSE.2024.3407840" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Metamorphic testing is a popular approach that aims to alleviate the oracle problem in software testing. At the core of this approach are Metamorphic Relations (MRs), specifying properties that hold among multiple test inputs and corresponding outputs. Deriving MRs is mostly a manual activity, since their automated generation is a challenging and largely unexplored problem. This paper presents GenMorph, a technique to automatically generate MRs for Java methods that involve inputs and outputs that are boolean, numerical, or ordered sequences. GenMorph uses an evolutionary algorithm to search for effective test oracles, i.e., oracles that trigger no false alarms and expose software faults in the method under test. The proposed search algorithm is guided by two fitness functions that measure the number of false alarms and the number of missed faults for the generated MRs. Our results show that GenMorph generates effective MRs for 18 out of 23 methods (mutation score &gt;= 20%). Furthermore, it can increase Randoop’s fault detection capability in 7 out of 23 methods, and Evosuite’s in 14 out of 23 methods. When compared with AUTOMR, a state-of-the-art MR generator, GenMorph also outperformed its fault detection capability in 9 out of 10 methods.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{ayerdi-genmorph-tse-2024,
  author = {Ayerdi, Jon and Terragni, Valerio and Jahangirova, Gunel and Arrieta, Aitor and Tonella, Paolo},
  journal = {IEEE Transactions on Software Engineering},
  title = {{GenMorph: Automatically Generating Metamorphic Relations via Genetic Programming}},
  year = {2024},
  volume = {50},
  number = {7},
  pages = {1888-1900},
  doi = {10.1109/TSE.2024.3407840}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>FSE 2024</i></span>



<div id="jayasuriya2024fse">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3643782" target="_blank">Understanding the Impact of APIs Behavioral Breaking Changes on Client Applications</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Dhanushka Jayasuriya,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jens Dietrich,
              
              
            
          
        
      
        
          
            
              
               
                  Kelly Blincoe
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>Proc. ACM Softw. Eng.</em>
     

    
    
    <em>, 2024</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/jayasuriya-fse-2024.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3643782" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Libraries play a significant role in software development as they provide reusable functionality, which helps expedite the development process. As libraries evolve, they release new versions with optimisations like new functionality, bug fixes, and patches for known security vulnerabilities. To obtain these optimisations, the client applications that depend on these libraries must update to use the latest version. However, this can cause software failures in the clients if the update includes breaking changes. These breaking changes can be divided into syntactic and semantic (behavioral) breaking changes. While there has been considerable research on syntactic breaking changes introduced between library updates and their impact on client projects, there is a notable lack of research regarding behavioral breaking changes introduced during library updates and their impacts on clients. We conducted an empirical analysis to identify the impact behavioral breaking changes have on clients by examining the impact of dependency updates on client test suites. We examined a set of java projects built using Maven, which included 30,548 dependencies under 8,086 Maven artifacts. We automatically updated out-of-date dependencies and ran the client test suites. We found that 2.30% of these updates had behavioral breaking changes that impacted client tests. Our results show that most breaking changes were introduced during a non-Major dependency update, violating the semantic versioning scheme. We further analyzed the effects these behavioral breaking changes have on client tests. We present a taxonomy of effects related to these changes, which we broadly categorize as Test Failures and Test Errors. Our results further indicate that the library developers did not adequately document the exceptions thrown due to precondition violations.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{jayasuriya2024fse,
  author = {Jayasuriya, Dhanushka and Terragni, Valerio and Dietrich, Jens and Blincoe, Kelly},
  title = {Understanding the Impact of APIs Behavioral Breaking Changes on Client Applications},
  year = {2024},
  volume = {1},
  number = {FSE},
  doi = {10.1145/3643782},
  journal = {Proc. ACM Softw. Eng.},
  month = jul,
  articleno = {56}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>IEEE Access</i></span>



<div id="chen2024ieee-access">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/ACCESS.2024.3514843" target="_blank">Detecting Learning Behavior in Programming Assignments by Analyzing
                  Versioned Repositories</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  John Chen,
              
              
            
          
        
      
        
          
            
              
               
                  Serena Lau,
              
              
            
          
        
      
        
          
            
              
               
                  Juho Leinonen,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Nasser Giacaman
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>IEEE Access</em>
     

    
    <em>, pages 188828–188844</em>
    
    
    <em>, 2024</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/chen-ieee-2024.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1109/ACCESS.2024.3514843" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Computing education plays a significant role in shaping the calibre of future computing professionals; hence, improving its quality is a valuable endeavour. A promising approach to enhance computing education is leveraging student data from version control systems (VCS). While previous studies have utilised VCS data to predict academic performance, there remains a gap in harnessing this data for learning analytics to understand student learning behaviours in real time. In this research, we introduce the Polivr ecosystem, a comprehensive platform designed to address this gap by utilising VCS data for learning analytics in computing education. The Polivr ecosystem comprises three key modules: Polivr Anonymiser, which ensures data privacy by anonymising student identities; Polivr Core, which mines learning metrics from Git repositories; and Polivr Web Viewer, which transforms the raw metrics into insightful visualisations for educators. We evaluated Polivr using anonymised repositories collected from undergraduate computing courses. The resulting visualisations revealed trends and patterns in student learning behaviours, such as coding habits and progression over time. These insights provide valuable information for educators to enhance teaching strategies and potentially identify at-risk students. This research demonstrates the potential of version control systems as a rich source of learning analytics, contributing to improving computing education by enabling data-driven decision-making in instructional design and student support.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{chen2024ieee-access,
  author = {Chen, John and Lau, Serena and Leinonen, Juho and Terragni, Valerio and Giacaman, Nasser},
  title = {Detecting Learning Behavior in Programming Assignments by Analyzing
                    Versioned Repositories},
  journal = {{IEEE} Access},
  volume = {12},
  pages = {188828--188844},
  year = {2024},
  doi = {10.1109/ACCESS.2024.3514843}
}
</p>
  </span>
</div>
</li>
</ol>

<h3 class="year">2023</h3>
<ol class="bibliography">
<li>
<span class="fa-li"><i>IEEE Software</i></span>



<div id="terragnifosteringapproach">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/ms.2023.3291711" target="_blank">Fostering Professionalism in Software Engineering: An Early-Exposure Approach</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Catherine Watson,
              
              
            
          
        
      
        
          
            
              
               
                   Rowe,
              
              
            
          
        
      
        
          
            
              
               
                  Nasser Giacaman
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>IEEE Software </em>
     

    
    <em>, pages 47-54</em>
    
    
    <em>, 2023</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-ieee-2023.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1109/ms.2023.3291711" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>In this article, we advocate for an early-exposure approach to professionalism in software engineering. We believe that it is important to start preparing students for the “culture” of software professionalism from early on, which gives them a competitive edge in their careers.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{terragnifosteringapproach,
  author = {Terragni, Valerio and Watson, Catherine and Rowe and Giacaman, Nasser},
  journal = {IEEE Software },
  title = {{Fostering Professionalism in Software Engineering: An Early-Exposure Approach}},
  year = {2023},
  volume = {40},
  number = {6},
  pages = {47-54},
  doi = {10.1109/ms.2023.3291711}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ISSTA 2023</i></span>



<div id="jayasuriya2023understandingwild">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3597926.3598147" target="_blank">Understanding Breaking Changes in the Wild</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Dhanuska Jayasuriya,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jens Dietrich,
              
              
            
          
        
      
        
          
            
              
               
                  Sam Ou,
              
              
            
          
        
      
        
          
            
              
               
                  Kelly Blincoe
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
            <em>In Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis</em>

    

    
    <em>, pages 1433–1444</em>
    
    
    <em>, 2023</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/jayasuriya-issta-2023.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3597926.3598147" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Modern software applications rely heavily on the usage of libraries, which provide reusable functionality, to accelerate the development process. As libraries evolve and release new versions, the software systems that depend on those libraries (the clients) should update their dependencies to use these new versions as the new release could, for example, include critical fixes for security vulnerabilities. However, updating is not always a smooth process, as it can result in software failures in the clients if the new version includes breaking changes. Yet, there is little research on how these breaking changes impact the client projects in the wild. To identify if changes between two library versions cause breaking changes at the client end, we perform an empirical study on Java projects built using Maven. For the analysis, we used 18,415 Maven artifacts, which declared 142,355 direct dependencies, of which 71.60% were not up-to-date. We updated these dependencies and found that 11.58% of the dependency updates contain breaking changes that impact the client. We further analyzed these changes in the library which impact the client projects and examine if libraries have adhered to the semantic versioning scheme when introducing breaking changes in their releases. Our results show that changes in transitive dependencies were a major factor in introducing breaking changes during dependency updates and almost half of the detected client impacting breaking changes violate the semantic versioning scheme by introducing breaking changes in non-Major updates.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{jayasuriya2023understandingwild,
  author = {Jayasuriya, Dhanuska and Terragni, Valerio and Dietrich, Jens and Ou, Sam and Blincoe, Kelly},
  pages = {1433--1444},
  title = {Understanding Breaking Changes in the Wild},
  year = {2023},
  doi = {10.1145/3597926.3598147},
  booktitle = {Proceedings of the 32nd ACM SIGSOFT International Symposium on Software Testing and Analysis}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>SBFT 2023</i></span>



<div id="jahangirova2023sbfttrack">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/sbft59156.2023.00025" target="_blank">SBFT Tool Competition 2023 - Java Test Case Generation Track</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Gunel Jahangirova,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the </em>
    
    

    
    <em>, pages 61–64</em>
    
    
    <em>, 2023</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/jahangirova-sbft-2023.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1109/sbft59156.2023.00025" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>This paper details the eleventh edition of Java Unit Testing Competition, covering its setup, challenges, and findings. The competition featured five Java test case generation tools: EvoSuite, Kex-
concolic, Kex-symbolic, Utbot-concolic, and Utbot-fuzzer, all
of which were evaluated on a benchmark of 100 classes taken from
5 open-source Java Projects. We assessed the generated test cases
based on code and mutation coverage, as well as human understandability - a metric introduced in this edition of the competition</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{jahangirova2023sbfttrack,
  author = {Jahangirova, Gunel and Terragni, Valerio},
  pages = {61--64},
  title = {SBFT Tool Competition 2023 - Java Test Case Generation Track},
  year = {2023},
  doi = {10.1109/sbft59156.2023.00025},
  conference = {IEEE/ACM International Workshop on Search-Based and Fuzz Testing}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICSE 2023</i></span>



<div id="iddon-icse-2023">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/ICSE-SEET58685.2023.00024" target="_blank">GradeStyle: GitHub-Integrated and Automated Assessment of Java Code Style</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Callum Iddon,
              
              
            
          
        
      
        
          
            
              
               
                  Nasser Giacaman,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the IEEE/ACM International Conference on Software Engineering, SEET track</em>
    
    

    
    <em>, pages 192–197</em>
    
    
    <em>, 2023</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/iddon-icse-2023.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
    [<a href="https://github.com/Digital-Educational-Engineering/gradestyle" target="_blank">Replication Package</a>]
  
      
    [<a href="http://www.doi.org/10.1109/ICSE-SEET58685.2023.00024" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Every programming language has its own style conventions and best practices, which help developers to write readable and maintainable code. Learning code style is an essential skill that every professional software engineer should master. As such, students should develop good habits for code style early on, when they start learning how to program. Unfortunately, manually assessing students’ code with timely and detailed feedback is often infeasible, and professional static analysis tools are unsuitable for educational contexts. This paper presents GRADESTYLE, a tool for automatically assessing the code style of Java assignments. GRADESTYLE automatically checks for violations of some of the most important Google Java Style conventions, and Java best practices. Students receive a report with a code style mark, a list of violations, and their source code locations. GRADESTYLE nicely integrates with GitHub and GitHub Classroom, and can be configured to provide continuous feedback every time a student pushes new code. We adopted our tool in a second-year software engineering programming course with 327 students and observed consistent improvements in the code style of their assignments.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{iddon-icse-2023,
  author = {Iddon, Callum and Giacaman, Nasser and Terragni, Valerio},
  title = {{GradeStyle: GitHub-Integrated and Automated Assessment of Java Code Style}},
  booktitle = {{IEEE/ACM} International Conference on Software Engineering, SEET track},
  year = {2023},
  doi = {10.1109/ICSE-SEET58685.2023.00024},
  pages = {192--197}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ACE 2023</i></span>



<div id="luxton-reilly-ace-2023">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3576123.3576124" target="_blank">Automated Assessment: Experiences From the Trenches</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Andrew Luxton-Reilly,
              
              
            
          
        
      
        
          
            
              
               
                  Ewan Tempero,
              
              
            
          
        
      
        
          
            
              
               
                  Nalin Arachchilage,
              
              
            
          
        
      
        
          
            
              
               
                  Angela Chang,
              
              
            
          
        
      
        
          
            
              
               
                  Paul Denny,
              
              
            
          
        
      
        
          
            
              
               
                  Allan Fowler,
              
              
            
          
        
      
        
          
            
              
               
                  Nasser Giacaman,
              
              
            
          
        
      
        
          
            
              
               
                  Igor Kontorovich,
              
              
            
          
        
      
        
          
            
              
               
                  Danielle Lottridge,
              
              
            
          
        
      
        
          
            
              
               
                  Sathiamoorthy Manoharan,
              
              
            
          
        
      
        
          
            
              
               
                  Shyamli Sindhwani,
              
              
            
          
        
      
        
          
            
              
               
                  Paramvir Singh,
              
              
            
          
        
      
        
          
            
              
               
                  Ulrich Speidel,
              
              
            
          
        
      
        
          
            
              
               
                  Sudeep Stephen,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jacqueline Whalley,
              
              
            
          
        
      
        
          
            
              
               
                  Burkhard Wuensche,
              
              
            
          
        
      
        
          
            
              
               
                  Xinfeng Ye
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
            <em>In Proceedings of the Australasian Computing Education Conference</em>

    

    
    <em>, pages 1–-10</em>
    
    
    <em>, 2023</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/luxton-ace-2023.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3576123.3576124" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Automated assessment is commonly used across the spectrum of computing courses offered by Tertiary institutions. Such assessment is frequently intended to address the scalability of feedback that is essential for learning, and assessment for accreditation purposes. Although many reviews of automated assessment have been reported, the voices of teachers are not present. In this paper we present a variety of cases that illustrate some of the varied motivations and experiences of teaching using automated assessment.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{luxton-reilly-ace-2023,
  author = {Luxton-Reilly, Andrew and Tempero, Ewan and Arachchilage, Nalin and Chang, Angela and Denny, Paul and Fowler, Allan and Giacaman, Nasser and Kontorovich, Igor and Lottridge, Danielle and Manoharan, Sathiamoorthy and Sindhwani, Shyamli and Singh, Paramvir and Speidel, Ulrich and Stephen, Sudeep and Terragni, Valerio and Whalley, Jacqueline and Wuensche, Burkhard and Ye, Xinfeng},
  title = {{Automated Assessment: Experiences From the Trenches}},
  booktitle = {Proceedings of the Australasian Computing Education Conference},
  year = {2023},
  pages = {1–-10},
  doi = {10.1145/3576123.3576124}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>SIGCSE 2023</i></span>



<div id="giacaman-sigcse-2023">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3545945.3569831" target="_blank">Evolving a Programming CS2 Course: A Decade-Long Experience Report</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Nasser Giacaman,
              
              
            
          
        
      
        
          
            
              
               
                  Partha Roop,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
            <em>In Proceedings of Technical Symposium on Computer Science Education</em>

    

    
    <em>, pages 507–513</em>
    
    
    <em>, 2023</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/giacaman-sigcse-2023.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3545945.3569831" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Despite instructors’ best efforts in designing and delivering any
given course, changes are likely required from time to time. This
experience report presents the changes made in a second-year programming course for non-computing engineering majors over a
decade’s worth of effort, and the reasons behind those changes. The
changes were often reactive—in response to student feedback. However, many other changes were inspired by the desire to trial new
interventions in the hope of strengthening the students’ positive
experience. In addition to personnel and course content changes, the
gradual evolvement included how labs, assignments, and activities
were structured and executed. Teaching delivery evolved, along with
a number of small-scale interventions that eventually became integral elements of the course. When COVID-19 demanded a sudden
shift to online learning, the course was prepared to adapt quickly
and successfully. The contributions here come in the form of lessons
learned over the past decade: what worked, and what did not. We
present the large range of changes and their rationales — that are particularly relevant and applicable to programming courses targeting
engineering students where the luxury of pedagogically-friendlier
programming languages is not possible</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{giacaman-sigcse-2023,
  author = {Giacaman, Nasser and Roop, Partha and Terragni, Valerio},
  title = {{Evolving a Programming CS2 Course: A Decade-Long Experience Report}},
  booktitle = {Proceedings of Technical Symposium on Computer Science Education},
  year = {2023},
  pages = {507--513},
  doi = {10.1145/3545945.3569831}
}
</p>
  </span>
</div>
</li>
</ol>

<h3 class="year">2022</h3>
<ol class="bibliography">
<li>
<span class="fa-li"><i>GECCO 2022</i></span>



<div id="ayerdigecco">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3520304.%203534077" target="_blank">Evolutionary Generation of Metamorphic Relations for Cyber-Physical Systems</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Jon Ayerdi,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Aitor Arrieta,
              
              
            
          
        
      
        
          
            
              
               
                  Paolo Tonella,
              
              
            
          
        
      
        
          
            
              
               
                  Goiuria Sagardui,
              
              
            
          
        
      
        
          
            
              
               
                  Maite Arratibel
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the Genetic and Evolutionary Computation Conference</em>
    
    

    
    
    <em>, 2022</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ayerdi-gecco-2022.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3520304.%203534077" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>A problem when testing Cyber-Physical Systems (CPS) is the difficulty of determining whether a particular system output or be- haviour is correct or not. Metamorphic testing alleviates such a problem by reasoning on the relations expected to hold among multiple executions of the system under test, which are known as Metamorphic Relations (MRs). However, the development of effective MRs is often challenging and requires the involvement of domain experts. This paper summarizes our recent publication:
	“Generating Metamorphic Relations for Cyber-Physical Systems with Genetic Programming: An Industrial Case Study”, presented at ESEC/FSE 2021. In that publication we presented GAssertMRs, the first technique to automatically generate MRs for CPS, leveraging GP to explore the space of candidate solutions. We evaluated GAssertMRs in an industrial case study, outperforming other baselines.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{ayerdigecco,
  author = {Ayerdi, Jon and Terragni, Valerio and Arrieta, Aitor and Tonella, Paolo and Sagardui, Goiuria and Arratibel, Maite},
  title = {{Evolutionary Generation of Metamorphic Relations for Cyber-Physical Systems}},
  booktitle = {Genetic and Evolutionary Computation Conference},
  year = {2022},
  doi = {10.1145/3520304. 3534077}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICPC 2022</i></span>



<div id="khalili-icpc-2022">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3524610.3527873" target="_blank">The Ineffectiveness of Domain-Specific Word Embedding Models for GUI Test Reuse</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Farideh Khalili,
              
              
            
          
        
      
        
          
            
              
               
                  Ali Mohebbi,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè,
              
              
            
          
        
      
        
          
            
              
               
                  Leonardo Mariani,
              
              
            
          
        
      
        
          
            
              
               
                  Abbas Heydarnoori
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 30th International Conference on Program Comprehension</em>
    
    

    
    
    <em>, 2022</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/khalili-icpc-2022.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3524610.3527873" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Reusing test cases across similar applications can significantly reduce testing effort. Some recent test reuse approaches successfully exploit word embedding models to semantically match GUI events across Android apps. It is a common understanding that word em- bedding models trained on domain-specific corpora perform better on specialized tasks. Our recent study confirms this understanding in the context of Android test reuse. It shows that word embedding models trained with a corpus of the English descriptions of apps in the Google Play Store lead to a better semantic matching of Android GUI events. Motivated by this result, we hypothesize that we can further increase the effectiveness of semantic matching by partitioning the corpus of app descriptions into domain-specific corpora. Our experiments do not confirm our hypothesis. This paper sheds light on this unexpected negative result that contradicts the common understanding. </p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{khalili-icpc-2022,
  author = {Khalili, Farideh and Mohebbi, Ali and Terragni, Valerio and Pezzè, Mauro and Mariani, Leonardo and Heydarnoori, Abbas},
  title = {{The Ineffectiveness of Domain-Specific Word Embedding Models for GUI Test Reuse}},
  booktitle = {30th International Conference on Program Comprehension},
  year = {2022},
  doi = {10.1145/3524610.3527873}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>SANER 2022</i></span>



<div id="baker-saner-2022">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/SANER53432.2022.00110" target="_blank">Detect, Fix, and Verify TensorFlow API Misuses</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Wilson Baker,
              
              
            
          
        
      
        
          
            
              
               
                  Michael O’Connor,
              
              
            
          
        
      
        
          
            
              
               
                  Seyed Reza Shahamiri,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 29th IEEE International Conference on Software Analysis, Evolution and Reengineering SANER 2022</em>
    
    

    
    
    <em>, 2022</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/baker-saner-2022.pdf" target="_blank">PDF</a>]
      
  
  
  

      
      [<a href="https://www.youtube.com/watch?v=b8y4qvAJhBc" target="_blank">Video</a>]
        
  
      
    [<a href="http://www.doi.org/10.1109/SANER53432.2022.00110" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>The growing application of DL makes detecting and fixing defective DL programs of paramount importance. Recent studies on DL defects report that TensorFlow API misuses represent a common class of DL defects. However to effectively detect, fix, and verify them remains an understudied problem. This paper presents the TensorFlow API misuses Detector And Fixer (TADAF) technique, which relies on 11 common API misuses patterns and corresponding fixes that we extracted from StackOverflow. TADAF statically analyses a TensorFlow program for identifying matches of any of the 11 patterns. If it finds a match, it automatically generates a fixed version of the program. To verify that the misuse brings a tangible negative effect, TADAF reports functional, accuracy, or efficiency differences when training and testing (with the same data) the original and fixed versions of the program. Our preliminary evaluation on five GitHub projects shows that TADAF detected and fixed all the API misuses. </p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{baker-saner-2022,
  author = {Baker, Wilson and O’Connor, Michael and Shahamiri, Seyed Reza and Terragni, Valerio},
  title = {Detect, Fix, and Verify TensorFlow API Misuses},
  booktitle = {29th IEEE International Conference on Software Analysis, Evolution and Reengineering {SANER} 2022},
  year = {2022},
  doi = {10.1109/SANER53432.2022.00110}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ACE 2022</i></span>



<div id="tu-ace-2022">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3511861.3511879" target="_blank">GitHub in the Classroom: Lessons Learnt</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Yu-Cheng Tu,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Ewan Tempero,
              
              
            
          
        
      
        
          
            
              
               
                  Asma Shakil,
              
              
            
          
        
      
        
          
            
              
               
                  Andrew Meads,
              
              
            
          
        
      
        
          
            
              
               
                  Nasser Giacaman,
              
              
            
          
        
      
        
          
            
              
               
                  Allan Fowler,
              
              
            
          
        
      
        
          
            
              
               
                  Kelly Blincoe
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
            <em>In Proceedings of the Australasian Computing Education Conference</em>

    

    
    
    <em>, 2022</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/tu-ace-2022.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3511861.3511879" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>The decision as to whether or not, and how, to use a Version Control System (VCS) in teaching is complex to make. There are a number of use cases for how a VCS can be used in teaching, there are several VCSs, each VCS has a variety of options for how to access them, each has a number of third-party support systems, and all combinations have different benefits, costs, and challenges. At University of Auckland, we have made significant use of Git and related systems (especially GitHub and GitHub Classroom). In this paper, we offer the lessons we have learned from our collective experience. While we by no means cover all of the possibilities, we hope that instructors considering the use of VCSs, in particular Git, will find the lessons we have learned helpful in making their decisions regarding how to use VCS in teaching. </p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{tu-ace-2022,
  author = {Tu, Yu-Cheng and Terragni, Valerio and Tempero, Ewan and Shakil, Asma and Meads, Andrew and Giacaman, Nasser and Fowler, Allan and Blincoe, Kelly},
  title = {GitHub in the Classroom: Lessons Learnt},
  booktitle = {Proceedings of the Australasian Computing Education Conference},
  year = {2022},
  doi = {10.1145/3511861.3511879}
}
</p>
  </span>
</div>
</li>
</ol>

<h3 class="year">2021</h3>
<ol class="bibliography">
<li>
<span class="fa-li"><i>GPEM 2021</i></span>



<div id="ruberto-gpem-2021">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1007/s10710-021-09419-3" target="_blank">A semantic genetic programming framework based on dynamic targets</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jason H. Moore
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>Genet. Program. Evolvable Mach.</em>
     

    
    <em>, pages 463–493</em>
    
    
    <em>, 2021</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ruberto-gpm-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1007/s10710-021-09419-3" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Semantic GP is a promising branch of GP that introduces semantic awareness during genetic evolution to improve various aspects of GP. This paper presents a new Semantic GP approach based on Dynamic Target (SGP-DT) that divides the search problem into multiple GP runs. The evolution in each run is guided by a new (dynamic) target based on the residual errors of previous runs. To obtain the final solution, SGP-DT combines the solutions of each run using linear scaling. SGP-DT presents a new methodology to produce the offspring that does not rely on the classic crossover. The synergy between such a methodology and linear scaling yields final solutions with low approximation error and computational cost. We evaluate SGP-DT on eleven well-known data sets and compare with 𝜖-lexicase, a state-ofthe-art evolutionary technique, and seven Machine Learning techniques. SGP-DT achieves small RMSE values, on average 23.19% smaller than the one of e-lexicase. Tuning SGP-DT ’s configuration greatly reduces the computational cost while still obtaining competitive results.
  </p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{ruberto-gpem-2021,
  author = {Ruberto, Stefano and Terragni, Valerio and Moore, Jason H.},
  title = {A semantic genetic programming framework based on dynamic targets},
  journal = {Genet. Program. Evolvable Mach.},
  volume = {22},
  number = {4},
  pages = {463--493},
  year = {2021},
  doi = {10.1007/s10710-021-09419-3}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ASE 2021</i></span>



<div id="terragni-ase-2021">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/ASE51524.2021.9678576" target="_blank">APIzation: Generating Reusable APIs from StackOverflow Code Snippets</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Pasquale Salza
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 36th IEEE/ACM International Conference on Automated Software Engineering</em>
    
    

    
    <em>, pages 542–554</em>
    
    
    <em>, 2021</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-ase-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
    [<a href="https://doi.org/10.5281/zenodo.5236305" target="_blank">Replication Package</a>]
  
      
    [<a href="http://www.doi.org/10.1109/ASE51524.2021.9678576" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Developer forums like StackOverflow have become essential resources to modern software development practices. However, many code snippets lack a well-defined method declaration, and thus they are often incomplete for immediate reuse. Developers must adapt the retrieved code snippets by parameterizing the variables involved and identifying the return value. This activity, which we call APIzation of a code snippet, can be tedious and time-consuming. In this paper, we present APIZATOR to perform APIzations of JAVA code snippets automatically. APIZATOR is grounded by four common patterns that we extracted by studying real APIzations in GitHub. APIZATOR presents a static analysis algorithm that automatically extracts the method parameters and return statements. We evaluated APIZATOR with a ground-truth of 200 APIzations collected from 20 developers. For 113 (56.50 %) and 115 (57.50%) APIzations, APIZATOR and the developers extracted identical parameters and return statements, respectively. For 163 (81.50 %) APIzations, either the parameters or the return statements were identical.
  </p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-ase-2021,
  author = {Terragni, Valerio and Salza, Pasquale},
  title = {{APIzation: Generating Reusable APIs from StackOverflow Code Snippets}},
  booktitle = {36th IEEE/ACM International Conference on Automated Software Engineering},
  year = {2021},
  pages = {542--554},
  doi = {10.1109/ASE51524.2021.9678576}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ESEC/ FSE 2021</i></span>



<div id="gassertmrs">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3468264.3473920" target="_blank">Generating Metamorphic Relations for Cyber-Physical Systems with Genetic Programming: An Industrial Case Study</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Jon Ayerdi,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Aitor Arrieta,
              
              
            
          
        
      
        
          
            
              
               
                  Paolo Tonella,
              
              
            
          
        
      
        
          
            
              
               
                  Goiuria Sagardui,
              
              
            
          
        
      
        
          
            
              
               
                  Maite Arratibel
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>
    
    

    
    <em>, pages 1264–1274</em>
    
    
    <em>, 2021</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ayerdi-fse-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3468264.3473920" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>One of the major challenges in the verification of complex industrial Cyber-Physical Systems is the difficulty of determining whether a particular system output or behaviour is correct or not, the so- called test oracle problem. Metamorphic testing alleviates the oracle problem by reasoning on the relations that are expected to hold among multiple executions of the system under test, which are known as Metamorphic Relations (MRs). However, the development of effective MRs is often challenging and requires the involvement of domain experts. In this paper, we present a case study aiming at automating this process. To this end, we implemented GAssertMRs, a tool to automatically generate MRs with genetic programming. We assess the cost-effectiveness of this tool in the context of an industrial case study from the elevation domain. Our experimental results show that in most cases GAssertMRs outperforms the other baselines, including manually generated MRs developed with the help of domain experts. We then describe the lessons learned from our experiments and we outline the future work for the adoption of this technique by industrial practitioners.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{gassertmrs,
  author = {Ayerdi, Jon and Terragni, Valerio and Arrieta, Aitor and Tonella, Paolo and Sagardui, Goiuria and Arratibel, Maite},
  title = {{Generating Metamorphic Relations for Cyber-Physical Systems with Genetic Programming: An Industrial Case Study}},
  booktitle = {29th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  year = {2021},
  doi = {10.1145/3468264.3473920},
  pages = {1264–1274}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>GECCO 2021</i></span>



<div id="ruberto-gecco-2021">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3449639.3459324" target="_blank">Towards Effective GP Multi-Class Classification Based
on Dynamic Targets</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jason H. Moore
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the Genetic and Evolutionary Computation Conference</em>
    
    

    
    <em>, pages 812–821</em>
    
    
    <em>, 2021</em>
    
    </span>
    
        <span class="periodical">
      <strong> <img class="emoji" title=":trophy:" alt=":trophy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c6.png" height="20" width="20"> Nominated for the Best Paper Award  </strong>
        </span>

    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ruberto-gecco-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3449639.3459324" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>In the multi-class classification problem GP plays an important role when combined with other non-GP classifiers. However, when GP performs the actual classification (without relying on other classifiers) its classification accuracy is low. This is especially true when the number of classes is high. In this paper, we present DTC, a GP classifier that leverages the effectiveness of the dynamic target approach to evolve a set of discriminant functions (one for each class). Notably, DTC is the first GP classifier that defines the fitness of individuals by using the synergistic combination of linear scaling and the hinge-loss function (commonly used by SVM). Differently, most previous GP classifiers use the number of correct classifications to drive the evolution. We compare DTC with eight state-of-art multi-class classification techniques (e.g., RF, RS, MLP, and SVM) on eight popular datasets. The results show that DTC achieves competitive classification accuracy even with 15 classes, without relying on other classifiers.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{ruberto-gecco-2021,
  author = {Ruberto, Stefano and Terragni, Valerio and Moore, Jason H.},
  title = {Towards Effective GP Multi-Class Classification Based
  on Dynamic Targets},
  doi = {10.1145/3449639.3459324},
  year = {2021},
  booktitle = {Genetic and Evolutionary Computation Conference},
  pages = {812–821}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>GECCO 2021</i></span>



<div id="terragni-gecco-2021">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3449726.3462722" target="_blank">Improving Assertion Oracles with Evolutionary Computation</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Gunel Jahangirova,
              
              
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè,
              
              
            
          
        
      
        
          
            
              
               
                  Paolo Tonella
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
            <em>In Proceedings of the Genetic and Evolutionary Computation Conference Companion</em>

    

    
    <em>, pages 45–46</em>
    
    
    <em>, 2021</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-gecco-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3449726.3462722" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Assertion oracles are executable boolean expressions placed inside a software program that verify the correctness of test executions. A perfect assertion oracle passes (returns true) for all correct executions and fails (returns false) for all incorrect executions. Because designing perfect assertion oracles is difficult, assertions often fail to distinguish between correct and incorrect executions. In other words, they are prone to false positives and false negatives. GAssert is the first technique to automatically improve assertion oracles by reducing false positives and false negatives. Given an assertion oracle and a set of correct and incorrect program states, GAssert employs a novel co-evolutionary algorithm that explores the space of possible assertions to identify one with fewer false positives and false negatives. Our evaluation on 34 Java methods shows that GAssert effectively improves assertion oracles.
</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-gecco-2021,
  author = {Terragni, Valerio and Jahangirova, Gunel and Pezzè, Mauro and Tonella, Paolo},
  title = {Improving Assertion Oracles with Evolutionary Computation},
  booktitle = {Proceedings of the Genetic and Evolutionary Computation Conference Companion},
  year = {2021},
  pages = {45–46},
  doi = {10.1145/3449726.3462722}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ISSTA 2021</i></span>



<div id="mariani-issta-2021">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3460319.3464827" target="_blank">Semantic Matching of GUI Events for Test Reuse: Are We There Yet?</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Leonardo Mariani,
              
              
            
          
        
      
        
          
            
              
               
                  Ali Mohebbi,
              
              
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
      (Authors are listed alphabetically)
    
    </span>


    <span class="periodical">
    
          
            <em>In Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis</em>

    

    
    <em>, pages 177–190</em>
    
    
    <em>, 2021</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/mariani-issta-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3460319.3464827" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>GUI testing is an important but expensive activity. Recently, research on test reuse approaches for Android applications produced interesting results. Test reuse approaches automatically migrate human-designed GUI tests from a source app to a target app that shares similar functionalities. They achieve this by exploiting semantic similarity among textual information of GUI widgets. Semantic matching of GUI events plays a crucial role in these approaches. In this paper, we present the first empirical study on semantic matching of GUI events. Our study involves 253 configurations of the semantic matching, 337 unique queries, and 8,099 distinct GUI events. We report several key findings that indicate how to improve semantic matching of test reuse approaches, pro- pose SemFinder a novel semantic matching algorithm that outperforms existing solutions, and identify several interesting research directions.
</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{mariani-issta-2021,
  author = {Mariani, Leonardo and Mohebbi, Ali and Pezzè, Mauro and Terragni, Valerio},
  title = {Semantic Matching of GUI Events for Test Reuse: Are We There Yet?},
  booktitle = {Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  year = {2021},
  pages = {177–190},
  doi = {10.1145/3460319.3464827}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>STVR 2021</i></span>



<div id="terragni-stvr-2021">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1002/stvr.1774" target="_blank">Statically driven generation of concurrent tests for thread-safe classes</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
      <em>Software Testing, Verification and Reliability</em>
     

    
    <em>, pages e1774</em>
    
    
    <em>, 2021</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-stvr-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1002/stvr.1774" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Concurrency testing is an important activity to expose concurrency faults in thread-safe classes. A concurrent test for a thread-safe class is a set of method call sequences that exercise the public interface of the class from multiple threads. Automatically generating fault-revealing concurrent tests within an affordable time budget is difficult due to the huge search space of possible concurrent tests. In this paper, we present DepCon+, a novel approach that reduces the search space of concurrent tests by leveraging statically computed dependencies among public methods. DepCon+ exploits the intuition that concurrent tests can expose thread-safety violations that manifest exceptions or deadlocks, only if they exercise some specific method dependencies. DepCon+ provides an efficient way to identify such dependencies by statically analysing the code and relies on the computed dependencies to steer the test generation towards those concurrent tests that exhibit the computed dependencies. We developed a prototype DepCon+ implementation for Java and evaluated the approach on 19 known concurrency faults of thread-safe classes that lead to thread-safety violations of either exception or deadlock type. The results presented in this paper show that DepCon+ is more effective than state-of-the-art approaches in exposing the concurrency faults. The search space pruning of DepCon+ dramatically reduces the search space of possible concurrent tests, without missing any thread-safety violations.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@article{terragni-stvr-2021,
  author = {Terragni, Valerio and Pezzè, Mauro},
  title = {Statically driven generation of concurrent tests for thread-safe classes},
  journal = {Software Testing, Verification and Reliability},
  volume = {31},
  number = {4},
  pages = {e1774},
  doi = {10.1002/stvr.1774},
  year = {2021}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICSE 2021</i></span>



<div id="terragni-icse-2021">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/ICSE-Companion52605.2021.00042" target="_blank">GAssert: A Fully Automated Tool to Improve Assertion Oracles</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Gunel Jahangirova,
              
              
            
          
        
      
        
          
            
              
               
                  Paolo Tonella,
              
              
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 43nd IEEE/ACM International Conference on Software Engineering Companion</em>
    
    

    
    <em>, pages 85-88</em>
    
    
    <em>, 2021</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-icse-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1109/ICSE-Companion52605.2021.00042" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>This demo presents the implementation and usage details of GASSERT, the first tool to automatically improve assertion oracles. Assertion oracles are executable boolean expressions placed inside the program that should pass (return true) for all correct executions and fail (return false) for all incorrect executions. Because designing perfect assertion oracles is difficult, assertions are prone to both false positives (the assertion fails but should pass) and false negatives (the assertion passes but should fail). Given a Java method containing an assertion oracle to improve, GASSERT returns an improved assertion with fewer false positives and false negatives than the initial assertion. Internally, GASSERT implements a novel co-evolutionary algorithm that explores the space of possible assertions guided by two fitness functions that reward assertions with fewer false positives, fewer false negatives, and smaller size.
</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-icse-2021,
  author = {Terragni, Valerio and Jahangirova, Gunel and Tonella, Paolo and Pezzè, Mauro},
  title = {GAssert: A Fully Automated Tool to Improve Assertion Oracles},
  booktitle = {43nd {IEEE/ACM} International Conference on Software Engineering Companion},
  year = {2021},
  pages = {85-88},
  doi = {10.1109/ICSE-Companion52605.2021.00042}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>AST 2021</i></span>



<div id="mariani-ast-2021">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/AST52587.2021.00016" target="_blank">An Evolutionary Approach to Adapt Tests Across Mobile Apps</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Leonardo Mariani,
              
              
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Daniele Zuddas
                
              
            
          
        
      

    
      (Authors are listed alphabetically)
    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the IEEE/ACM International Conference on Automation of Software Test (AST) </em>
    
    

    
    <em>, pages 70-79</em>
    
    
    <em>, 2021</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/mariani-ast-2021.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1109/AST52587.2021.00016" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Automatic generators of GUI tests often fail to generate semantically relevant test cases, and thus miss important test scenarios. To address this issue, test adaptation techniques can be used to automatically generate semantically meaningful GUI tests from test cases of applications with similar functionalities. In this paper, we present ADAPTDROID, a technique that approaches the test adaptation problem as a search-problem, and uses evolutionary testing to adapt GUI tests (including oracles) across similar Android apps. In our evaluation with 32 popular Android apps, ADAPTDROID successfully adapted semantically relevant test cases in 11 out of 20 cross-app adaptation scenarios.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{mariani-ast-2021,
  author = {Mariani, Leonardo and Pezzè, Mauro and Terragni, Valerio and Zuddas, Daniele},
  title = {An Evolutionary Approach to Adapt Tests Across Mobile Apps},
  booktitle = {IEEE/ACM International Conference on Automation of Software Test (AST) },
  pages = {70-79},
  doi = {10.1109/AST52587.2021.00016},
  year = {2021}
}
</p>
  </span>
</div>
</li>
</ol>

<h3 class="year">2020</h3>
<ol class="bibliography">
<li>
<span class="fa-li"><i>ESEC/ FSE 2020</i></span>



<div id="terragni-fse-2020">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3368089.3409758" target="_blank">Evolutionary Improvement of Assertion Oracles</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Gunel Jahangirova,
              
              
            
          
        
      
        
          
            
              
               
                  Paolo Tonella,
              
              
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 28th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>
    
    

    
    <em>, pages 1178–1189</em>
    
    
    <em>, 2020</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-esecfse-2020.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3368089.3409758" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Assertion oracles are executable boolean expressions placed inside the program that should pass (return true) for all correct executions and fail (return false) for all incorrect executions. Because designing perfect assertion oracles is difficult, assertions often fail to distinguish between correct and incorrect executions. In other words, they are prone to false positives and false negatives. In this paper, we propose GAssert (Genetic ASSERTion improvement), the first technique to automatically improve assertion oracles. Given an assertion oracle and evidence of false positives and false negatives, GAssert implements a novel co-evolutionary algorithm that explores the space of possible assertions to identify one with fewer false positives and false negatives. Our empirical evaluation on 34 Java methods from 7 different Java code bases shows that GAssert effectively improves assertion oracles. GAssert outperforms two baselines (random and invariant- based oracle improvement), and is comparable with and in some cases even outperformed human-improved assertions.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-fse-2020,
  author = {Terragni, Valerio and Jahangirova, Gunel and Tonella, Paolo and Pezzè, Mauro},
  title = {Evolutionary Improvement of Assertion Oracles},
  booktitle = {28th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  year = {2020},
  pages = {1178–1189},
  doi = {10.1145/3368089.3409758}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICSE 2020</i></span>



<div id="terragni-icse-2020">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3377816.3381742" target="_blank">A Container-Based Infrastructure for Fuzzy-Driven Root
             Causing of Flaky Tests</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Pasquale Salza,
              
              
            
          
        
      
        
          
            
              
               
                  Filomena Ferrucci
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the   42nd IEEE/ACM International Conference on Software Engineering: New Ideas and Emerging Results (ICSE-NIER)</em>
    
    

    
    <em>, pages 69-72</em>
    
    
    <em>, 2020</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-icse-2020.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3377816.3381742" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Intermittent test failures (test flakiness) is common during continuous integration as modern software systems have become inherently non-deterministic. Understanding the root cause of test flakiness is crucial as intermittent test failures might be the result of real non-deterministic defects in the production code, rather than mere errors in the test code. Given a flaky test, existing techniques for root causing test flakiness compare the runtime behavior of its passing and failing executions. They achieve this by repetitively executing the flaky test on an instrumented version of the system under test. This approach has two fundamental limitations: (i) code instrumentation might prevent the manifestation of test flakiness; (ii) when test flakiness is rare passively re-executing a test many times might be inadequate to trigger intermittent test outcomes. To address these limitations, we propose a new idea for root causing test flakiness that actively explores the non-deterministic space without instrumenting code. Our novel idea is to repetitively execute a flaky test, under different execution clusters. Each cluster explores a certain non-deterministic dimension (e.g., concurrency, I/O, and networking) with dedicated software containers and fuzzy- driven resource load generators. The execution cluster that manifests the most balanced (or unbalanced) sets of passing and failing executions is likely to explain the broad type of test flakiness.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-icse-2020,
  author = {Terragni, Valerio and Salza, Pasquale and Ferrucci, Filomena},
  title = {{A Container-Based Infrastructure for Fuzzy-Driven Root
               Causing of Flaky Tests}},
  booktitle = {  42nd IEEE/ACM International Conference on Software Engineering: New Ideas and Emerging Results (ICSE-NIER)},
  pages = {69-72},
  year = {2020},
  doi = {10.1145/3377816.3381742}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICPC 2020</i></span>



<div id="terragni-icpc-2020">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3387904.3389273" target="_blank">Measauring Software Testability Modulo Test Quality</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Pasquale Salza,
              
              
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 28th International Conference on Program Comprehension</em>
    
    

    
    <em>, pages 241-251</em>
    
    
    <em>, 2020</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-icpc-2020.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/terragni-icpc-2020-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
    [<a href="https://github.com/pasqualesalza/testability" target="_blank">Replication Package</a>]
  
      
    [<a href="http://www.doi.org/10.1145/3387904.3389273" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Comprehending the degree to which software components support testing is important to accurately schedule testing activities, train developers, and plan effective refactoring actions. Software testability estimates such property by relating code characteristics to the test effort. The main studies of testability reported in the literature investigate the relation between class metrics and test effort in terms of the size and complexity of the associated test suites. They report a moderate correlation of some class metrics to test-effort metrics, but suffer from two main limitations: (i) the results hardly generalize due to the small empirical evidence (datasets with no more than eight software projects); and (ii) mostly ignore the quality of the tests. However, considering the quality of the tests is important. Indeed, a class may have a low test effort because the associated tests are of poor quality, and not because the class is easier to test. In this paper, we propose an approach to measure testability that normalizes the test effort with respect to the test quality, which we quantify in terms of code coverage and mutation score. We present the results of a set of experiments on a dataset of 9,861 Java classes, belonging to 1,186 open source projects, with around 1.5 millions of lines of code overall. The results confirm that normalizing the test effort with respect to the test quality largely improves the correlation between class metrics and the test effort. Better correlations result in better prediction power, and thus better prediction of the test effort.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-icpc-2020,
  author = {Terragni, Valerio and Salza, Pasquale and Pezzè, Mauro},
  title = {{Measauring Software Testability Modulo Test Quality}},
  booktitle = {28th International Conference on Program Comprehension},
  year = {2020},
  pages = {241-251},
  doi = {10.1145/3387904.3389273}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>PPSN 2020</i></span>



<div id="ruberto-ppsn-2020">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1007/978-3-030-58115-2_5" target="_blank">Image Feature Learning with Genetic Programming</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jason H. Moore
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 16th International Conference on Parallel Problem Solving from Nature</em>
    
    

    
    <em>, pages 63–78</em>
    
    
    <em>, 2020</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ruberto-ppsn-2020.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1007/978-3-030-58115-2_5" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Learning features from raw data is an important topic in machine learning. This paper presents Genetic Program Feature Learner (GPFL), a novel generative GP feature learner for 2D images. GPFL executes multiple GP runs, each run generates a model that focuses on a particular high-level feature of the training images. Then, it combines the models generated by each run into a function that reconstructs the observed images. As a sanity check, we evaluated GPFL on the popular MNIST dataset of handwritten digits, and compared it with the convolutional neural network LeNet5. Our evaluation results show that when considering smaller training sets, GPFL achieves comparable/slightly- better classification accuracy than LeNet5. However, GPFL drastically outperforms LeNet5 when considering noisy images as test sets.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{ruberto-ppsn-2020,
  author = {Ruberto, Stefano and Terragni, Valerio and Moore, Jason H.},
  title = {Image Feature Learning with Genetic Programming},
  booktitle = {16th International Conference on Parallel Problem Solving from Nature},
  year = {2020},
  pages = {63--78},
  doi = {10.1007/978-3-030-58115-2\_5}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>GECCO 2020</i></span>



<div id="ruberto-gecco-2020b">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3377929.3397486" target="_blank">SGP-DT: Towards Effective Symbolic Regression with a Semantic GP Approach Based on Dynamic Targets</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jason H. Moore
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the Genetic and Evolutionary Computation Conference Companion</em>
    
    

    
    <em>, pages 25-26</em>
    
    
    <em>, 2020</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ruberto-gecco-hop-2020.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3377929.3397486" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Semantic Genetic Programming (SGP) approaches demonstrated remarkable results in different domains. SGP-DT is one of the latest of such approaches. Notably, SGP-DT proposes a dynamic-target approach that combines multiple GP runs without relying on any form of crossover. On eight well-known datasets SGP-DT achieves small RMSE, on average 25% smaller than state-of-the-art approaches.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{ruberto-gecco-2020b,
  author = {Ruberto, Stefano and Terragni, Valerio and Moore, Jason H.},
  title = {SGP-DT: Towards Effective Symbolic Regression with a Semantic GP Approach Based on Dynamic Targets},
  booktitle = {Genetic and Evolutionary Computation Conference Companion},
  year = {2020},
  pages = {25-26},
  doi = {10.1145/3377929.3397486}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>GECCO 2020</i></span>



<div id="ruberto-gecco-2020">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3377929.3389981" target="_blank">Image Feature Learning with a Genetic Programming Autoencoder</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jason H. Moore
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the Genetic and Evolutionary Computation Conference Companion</em>
    
    

    
    <em>, pages 245-246</em>
    
    
    <em>, 2020</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ruberto-gecco-2020.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1145/3377929.3389981" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Learning features from raw data is an important topic in machine learning. This paper presents a novel GP approach to learn high- level features from 2D images. It is a generative approach that resembles the concept of an autoencoder. Our approach executes multiple GP runs, each run generates a (partial) model that focuses on a particular high-level feature of the training images. Then, it combines the models generated by each run into a parametric function that reconstructs the observed images. We evaluated our approach on the popular MNIST dataset of 2D images representing handwritten digits. Our evaluation results show that our parametric approach can precisely reconstruct the MNIST hand-written digits.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{ruberto-gecco-2020,
  author = {Ruberto, Stefano and Terragni, Valerio and Moore, Jason H.},
  title = {Image Feature Learning with a Genetic Programming Autoencoder},
  booktitle = {Genetic and Evolutionary Computation Conference Companion},
  year = {2020},
  doi = {10.1145/3377929.3389981},
  pages = {245-246}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>EuroGP 2020</i></span>



<div id="ruberto-eurogp-2020">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1007/978-3-030-44094-7_11" target="_blank">SGP-DT: Semantic Genetic Programming Based on Dynamic Targets</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Jason H. Moore
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 23rd European Conference on Genetic Programming</em>
    
    

    
    <em>, pages 167-183</em>
    
    
    <em>, 2020</em>
    
    </span>
    
        <span class="periodical">
      <strong> <img class="emoji" title=":trophy:" alt=":trophy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c6.png" height="20" width="20"> Nominated for the Best Paper Award  </strong>
        </span>

    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/ruberto-eurogp-2020.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/ruberto-eurogp-2020-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
      
    [<a href="http://www.doi.org/10.1007/978-3-030-44094-7_11" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Semantic GP is a promising approach that introduces semantic awareness during genetic evolution. This paper presents a new Semantic GP approach based on Dynamic Target (SGP-DT) that divides the search problem into multiple GP runs. The evolution in each run is guided by a new (dynamic) target based on the residual errors. To obtain the final solution, SGP-DT combines the solutions of each run using linear scaling. SGP-DT presents a new methodology to produce the offspring that does not rely on the classic crossover. The synergy between such a methodology and linear scaling yields to final solutions with low approximation error and computational cost. We evaluate SGP-DT on eight well-known data sets and compare with epsilon-lexicase, a state-of-the-art evolutionary technique. SGP-DT achieves small RMSE values, on average 23.19% smaller than the one of epsilon-lexicase.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{ruberto-eurogp-2020,
  author = {Ruberto, Stefano and Terragni, Valerio and Moore, Jason H.},
  title = {{SGP-DT:} Semantic Genetic Programming Based on Dynamic Targets},
  booktitle = {23rd European Conference on Genetic Programming},
  pages = {167-183},
  year = {2020},
  doi = {10.1007/978-3-030-44094-7\_11}
}
</p>
  </span>
</div>
</li>
</ol>

<h3 class="year">2019</h3>
<ol class="bibliography"><li>
<span class="fa-li"><i>ICST 2019</i></span>



<div id="terragni-icst-2019">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/ICST.2019.00034" target="_blank">Coverage-Driven Test Generation for Thread-Safe Classes via Parallel
               and Conflict Dependencies</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè,
              
              
            
          
        
      
        
          
            
              
               
                  Francesco Adalberto Bianchi
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 12th IEEE Conference on Software Testing, Validation and Verification</em>
    
    

    
    <em>, pages 264-275</em>
    
    
    <em>, 2019</em>
    
    </span>
    
        <span class="periodical">
      <strong> <img class="emoji" title=":trophy:" alt=":trophy:" src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c6.png" height="20" width="20"> IEEE TCSE Distinguished Paper Award  </strong>
        </span>

    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-icst-2019.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/terragni-icst-2019-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
      
    [<a href="http://www.doi.org/10.1109/ICST.2019.00034" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Thread-safe classes are common in concurrent object-oriented programs. Testing such classes is important to ensure the reliability of the concurrent programs that rely on them. Recently, researchers have proposed the automated generation of concurrent (multi-threaded) tests to expose concurrency faults in thread-safe classes (thread-safety violations). However, generating fault-revealing concurrent tests within an affordable time-budget is difficult due to the huge search space of possible concurrent tests. In this paper, we present DEPCON, an approach to effectively reduce the search space of concurrent tests by means of both parallel and conflict dependency analyses. DEPCON is based on the intuition that only methods that can both interleave (parallel dependent) and access the same shared memory locations (conflict dependent) can lead to thread-safety violations when concurrently executed. DEPCON implements an efficient static analysis to compute the parallel and conflict dependencies among the methods of a class and uses the computed dependencies to steer the generation of tests towards concurrent tests that exhibit the computed dependencies. We evaluated DEPCON by experimenting with a prototype implementation for Java programs on a set of thread-safe classes with known concurrency faults. The experimental results show that DEPCON is more effective in exposing concurrency faults than state-of-theart techniques.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-icst-2019,
  author = {Terragni, Valerio and Pezz{\`{e}}, Mauro and Bianchi, Francesco Adalberto},
  title = {Coverage-Driven Test Generation for Thread-Safe Classes via Parallel
                 and Conflict Dependencies},
  booktitle = {12th {IEEE} Conference on Software Testing, Validation and Verification},
  pages = {264-275},
  year = {2019},
  doi = {10.1109/ICST.2019.00034}
}
</p>
  </span>
</div>
</li></ol>

<h3 class="year">2018</h3>
<ol class="bibliography"><li>
<span class="fa-li"><i>ASE 2018</i></span>



<div id="terragni-ase-2018">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3238147.3238224" target="_blank">Effectiveness and Challenges in Generating Concurrent Tests for Thread-Safe Classes</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 33rd ACM/IEEE International Conference on Automated
               Software Engineering</em>
    
    

    
    <em>, pages 64-75</em>
    
    
    <em>, 2018</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-ase-2018.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/terragni-ase-2018-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
      
    [<a href="http://www.doi.org/10.1145/3238147.3238224" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Developing correct and efficient concurrent programs is difficult and error-prone, due to the complexity of thread synchronization. Often, developers alleviate such problem by relying on thread-safe classes, which encapsulate most synchronization-related challenges. Thus, testing such classes is crucial to ensure the reliability of the concurrency aspects of programs. Some recent techniques and corresponding tools tackle the problem of testing thread-safe classes by automatically generating concurrent tests. In this paper, we present a comprehensive study of the state-of-the-art techniques and an independent empirical evaluation of the publicly available tools. We conducted the study by executing all tools on the JaConTeBe benchmark that contains 47 well-documented concurrency faults. Our results show that 8 out of 47 faults (17%) were detected by at least one tool. By studying the issues of the tools and the generated tests, we derive insights to guide future research on improving the effectiveness of automated concurrent test generation.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-ase-2018,
  author = {Terragni, Valerio and Pezz{\`{e}}, Mauro},
  title = {Effectiveness and Challenges in Generating Concurrent Tests for Thread-Safe Classes},
  booktitle = {33rd {ACM/IEEE} International Conference on Automated
                 Software Engineering},
  pages = {64-75},
  doi = {10.1145/3238147.3238224},
  year = {2018}
}
</p>
  </span>
</div>
</li></ol>

<h3 class="year">2017</h3>
<ol class="bibliography"><li>
<span class="fa-li"><i>ESEC/ FSE 2017</i></span>



<div id="bianchi-fse-2017">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/3106237.3106292" target="_blank">Reproducing Concurrency Failures from Crash Stacks</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Francesco A. Bianchi,
              
              
            
          
        
      
        
          
            
              
               
                  Mauro Pezzè,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
      (Authors are listed alphabetically)
    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 11th Joint Meeting on Foundations of Software
               Engineering</em>
    
    

    
    <em>, pages 705-716</em>
    
    
    <em>, 2017</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/bianchi-fse-2017.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/bianchi-fse-2017-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
    [<a href="http://star.inf.usi.ch/#/software-data/2" target="_blank">Replication Package</a>]
  
      
    [<a href="http://www.doi.org/10.1145/3106237.3106292" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Reproducing  field failures is the first essential step for understanding, localizing and removing faults. Reproducing concurrency field failures is hard due to the need of synthesizing a test code jointly with a thread interleaving that induce the failure in the presence of limited information from the field. Current techniques for reproducing concurrency failures focus on identifying failure-inducing interleavings, leaving largely open the problem of synthesizing the test code that manifests such interleavings. In this paper, we present ConCrash, a technique to automatically generate test codes that reproduce concurrency failures that violate thread-safety from crash stacks, which commonly summarize the conditions of field failures. ConCrash efficiently explores the huge space of possible test codes to identify a failure-inducing one by using a suitable set of search pruning strategies. Combined with existing techniques for exploring interleavings, ConCrash automatically reproduces a given concurrency failure that violates the thread-safety of a class by identifying both a failure-inducing test code and corresponding interleaving. In the paper, we define the ConCrash approach, present a prototype implementation of ConCrash, and discuss the experimental results that we obtained on a known set of ten field failures that witness the effectiveness of the approach.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{bianchi-fse-2017,
  author = {Bianchi, Francesco A. and Pezz{\`{e}}, Mauro and Terragni, Valerio},
  title = {Reproducing Concurrency Failures from Crash Stacks},
  booktitle = {11th Joint Meeting on Foundations of Software
                 Engineering},
  pages = {705-716},
  year = {2017},
  doi = {10.1145/3106237.3106292}
}
</p>
  </span>
</div>
</li></ol>

<h3 class="year">2016</h3>
<ol class="bibliography">
<li>
<span class="fa-li"><i>ICSE 2016</i></span>



<div id="terragni-icse-2016">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/2884781.2884876" target="_blank">Coverage-driven Test Code Generation for Concurrent Classes</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 38th ACM/IEEE International Conference on Software Engineering</em>
    
    

    
    <em>, pages 1121-1132</em>
    
    
    <em>, 2016</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-icse-2016.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/terragni-icse-2016-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
      
    [<a href="http://www.doi.org/10.1145/2884781.2884876" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Previous techniques on concurrency testing have mainly focused on exploring the interleaving space of manually written test code to expose faulty interleavings of shared memory accesses. These techniques assume the availability of failure-inducing tests. In this paper, we present AutoConTest, a coverage-driven approach to generate effective concurrent test code that achieve high interleaving coverage. AutoConTest consists of three components. First, it computes the coverage requirements dynamically and iteratively during sequential test code generation, using a coverage metric that captures the execution context of shared memory accesses. Second, it smartly selects these sequential codes based on the computed result and assembles them for concurrent tests, achieving increased context-sensitive interleaving coverage. Third, it explores the newly covered interleavings. We have implemented AutoConTest as an automated tool and evaluated it using 6 real-world concurrent Java subjects. The results show that AutoConTest is able to generate effective concurrent tests that achieve high interleaving coverage and expose concurrency faults quickly. AutoConTest took less than 65 seconds (including program analysis, test generation and execution) to expose the faults in the program subjects.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-icse-2016,
  author = {Terragni, Valerio and Cheung, Shing{-}Chi},
  title = {Coverage-driven Test Code Generation for Concurrent Classes},
  booktitle = {38th {ACM/IEEE} International Conference on Software Engineering},
  pages = {1121-1132},
  year = {2016},
  doi = {10.1145/2884781.2884876}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ISSTA 2016</i></span>



<div id="terragni-issta-2016">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/2931037.2931058" target="_blank">CSNIPPEX: Automated Synthesis of Compilable Code Snippets from Q&amp;A
               Sites</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Yepang Liu,
              
              
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 25th International Symposium on Software Testing
               and Analysis</em>
    
    

    
    <em>, pages 118-129</em>
    
    
    <em>, 2016</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-issta-2016.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/terragni-issta-2016-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
    [<a href="http://sccpu2.cse.ust.hk/csnippex/index.html" target="_blank">Replication Package</a>]
  
      
    [<a href="http://www.doi.org/10.1145/2931037.2931058" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Popular Q&amp;A sites like StackOverflow have collected numerous code snippets. However, many of them do not have complete type information, making them uncompilable and inapplicable to various software engineering tasks. This paper analyzes this problem, and proposes a technique CSNIPPEX to automatically convert code snippets into compilable Java source code files by resolving external dependencies, generating import declarations, and fixing syntactic errors. We implemented CSNIPPEX as a plug-in for Eclipse and evaluated it with 242,175 StackOverflow posts that contain code snippets. CSNIPPEX successfully synthesized compilable Java files for 40,410 of them. It was also able to effectively recover import declarations for each post with a precision of 91.04% in a couple of seconds.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-issta-2016,
  author = {Terragni, Valerio and Liu, Yepang and Cheung, Shing{-}Chi},
  title = {{CSNIPPEX:} Automated Synthesis of Compilable Code Snippets from Q{\&amp;}A
                 Sites},
  booktitle = {25th International Symposium on Software Testing
                 and Analysis},
  pages = {118-129},
  year = {2016},
  doi = {10.1145/2931037.2931058}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>FSE 2016</i></span>



<div id="liu-fse-2016">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1145/2950290.2950297" target="_blank">Understanding and Detecting Wake Lock Misuses for Android Applications</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Yepang Liu,
              
              
            
          
        
      
        
          
            
              
               
                  Chang Xu,
              
              
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 24th ACM SIGSOFT International Symposium on
               Foundations of Software Engineering</em>
    
    

    
    <em>, pages 396-409</em>
    
    
    <em>, 2016</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/liu-fse-2016.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/liu-fse-2016-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
    [<a href="http://sccpu2.cse.ust.hk/elite/toc.html" target="_blank">Replication Package</a>]
  
      
    [<a href="http://www.doi.org/10.1145/2950290.2950297" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Wake locks are widely used in Android apps to protect critical computations from being disrupted by device sleeping. Inappropriate use of wake locks often seriously impacts user experience. However, little is known on how wake locks are used in real-world Android apps and the impact of their misuses. To bridge the gap, we conducted a large-scale empirical study on 44,736 commercial and 31 open-source Android apps. By automated program analysis and manual investigation, we observed (1) common program points where wake locks are acquired and released, (2) 13 types of critical computational tasks that are often protected by wake locks, and (3) eight patterns of wake lock misuses that commonly cause functional and non-functional issues, only three of which had been studied by existing work. Based on our findings, we designed a static analysis technique, Elite, to detect two most common patterns of wake lock misuses. Our experiments on real-world subjects showed that Elite is effective and can outperform two state-of-the-art techniques.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{liu-fse-2016,
  author = {Liu, Yepang and Xu, Chang and Cheung, Shing{-}Chi and Terragni, Valerio},
  title = {Understanding and Detecting Wake Lock Misuses for Android Applications},
  booktitle = {24th {ACM} {SIGSOFT} International Symposium on
                 Foundations of Software Engineering},
  pages = {396-409},
  year = {2016},
  doi = {10.1145/2950290.2950297}
}
</p>
  </span>
</div>
</li>
</ol>

<h3 class="year">2015</h3>
<ol class="bibliography">
<li>
<span class="fa-li"><i>MOBILE Soft 2015</i></span>



<div id="malavolta-mobilesoft-2015">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/MobileSoft.2015.15" target="_blank">Hybrid Mobile Apps in the Google Play Store: An Exploratory Investigation</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Ivano Malavolta,
              
              
            
          
        
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              
               
                  Tommaso Soru,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 2nd ACM International Conference on Mobile Software Engineering and Systems</em>
    
    

    
    <em>, pages 56-59</em>
    
    
    <em>, 2015</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/malavolta-mobilesoft-2015.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1109/MobileSoft.2015.15" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>One of the most intriguing challenges in mobile apps development is its fragmentation with respect to mobile platforms (e.g., Android, Apple iOS, Windows Phone). Large companies like IBM and Adobe and a growing community of developers advocate hybrid mobile apps development as a possible solution to mobile platforms fragmentation. Hybrid mobile apps are consistent across platforms and built on web standards. How hybrid apps are performing in production settings is still highly debated, with limited objective evidence.In this paper, we present the first realistic investigation into mobile hybrid apps through a solid empirical strategy. Our goal is exploratory and we aim at identifying, analysing, and understanding the traits and distinctions of publicly available hybrid mobile apps within their real-life context. The study has been conducted by mining 11,917 free apps and 3,041,315 reviews from the Google Play Store, and analyzing them from both a technical and end users’ perception perspective. The results of this study build an objective and reproducible snapshot about how hybrid mobile development is performing "in the wild" in real projects.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{malavolta-mobilesoft-2015,
  author = {Malavolta, Ivano and Ruberto, Stefano and Soru, Tommaso and Terragni, Valerio},
  title = {Hybrid Mobile Apps in the Google Play Store: An Exploratory Investigation},
  booktitle = {2nd {ACM} International Conference on Mobile Software Engineering and Systems},
  pages = {56-59},
  year = {2015},
  doi = {10.1109/MobileSoft.2015.15}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>ICSE 2015</i></span>



<div id="terragni-icse-2015">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/ICSE.2015.45" target="_blank">RECONTEST: Effective Regression Testing of Concurrent Programs</a> 
</span>
  
    <span class="author">
      
        
          
            
              <strong>Valerio Terragni</strong>,
            
          
        
      
        
          
            
              
               
                  Shing-Chi Cheung,
              
              
            
          
        
      
        
          
            
              
               
                  Charles Zhang
                
              
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the 37th IEEE/ACM International Conference on Software Engineering</em>
    
    

    
    <em>, pages 246–256</em>
    
    
    <em>, 2015</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/terragni-icse-2015.pdf" target="_blank">PDF</a>]
      
  
  
  

            
    [<a href="/assets/pdf/terragni-icse-2015-slides.pdf" target="_blank">Slides</a>]
  
        
      
  
      
    [<a href="http://www.doi.org/10.1109/ICSE.2015.45" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Concurrent programs proliferate as multi-core technologies advance. As a result, the conventional approach that selects a sub-set of test cases for regression testing without considering interleavings is insufficient. In this paper we present RECONTEST to address the problem by selecting the new interleavings that arise due to code changes. These interleavings must be explored in order to uncover regression bugs. RECONTEST efficiently selects new interleavings by first identifying shared memory accesses that are affected by the changes, and then exploring only those problematic interleavings that contain at least one of these accesses.
We have implemented RECONTEST as an automated  tool and evaluated it using 13 real-world concurrent program subjects. Our results show that RECONTEST can significantly reduce the regression testing cost without missing any faulty interleavings induced by code changes.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{terragni-icse-2015,
  author = {Terragni, Valerio and Cheung, Shing{-}Chi and Zhang, Charles},
  title = {{RECONTEST:} Effective Regression Testing of Concurrent Programs},
  booktitle = {37th {IEEE/ACM} International Conference on Software Engineering},
  pages = {246--256},
  year = {2015},
  doi = {10.1109/ICSE.2015.45}
}
</p>
  </span>
</div>
</li>
<li>
<span class="fa-li"><i>MS 2015</i></span>



<div id="malavolta-ms-2015">
  
      
        <span class="title">                <a href="http://www.doi.org/10.1109/MobServ.2015.14" target="_blank">End Users’ Perception of Hybrid Mobile Apps in the Google Play Store</a> 
</span>
  
    <span class="author">
      
        
          
            
              
               
                  Ivano Malavolta,
              
              
            
          
        
      
        
          
            
              
               
                  Stefano Ruberto,
              
              
            
          
        
      
        
          
            
              
               
                  Tommaso Soru,
              
              
            
          
        
      
        
          
            
              <strong>Valerio Terragni</strong>
            
          
        
      

    
    </span>


    <span class="periodical">
    
          
      <em>In Proceedings of the IEEE International Conference on Mobile Services</em>
    
    

    
    <em>, pages 25-32</em>
    
    
    <em>, 2015</em>
    
    </span>
    

  

  <span class="links">
    [<a class="bibtex">BIBTEX</a>]
  
    [<a class="abstract">Abstract</a>]
  
  
  
  
      
    [<a href="/assets/pdf/malavolta-ms-2015.pdf" target="_blank">PDF</a>]
      
  
  
  

      
  
      
    [<a href="http://www.doi.org/10.1109/MobServ.2015.14" target="_blank">DOI</a>]
  
  </span>

  <!-- Hidden abstract block -->
  
  <span class="abstract hidden">
    <p>Today millions of mobile apps are downloaded and used all over the world. Mobile apps are distributed via different app stores, such as the Google Play Store, the Apple App Store, the Windows Phone Store. One of the most intriguing challenges in mobile apps development is its fragmentation with respect to mobile platforms (e.g., Android, Apple iOS, Windows Phone). Recently, companies like IBM and Adobe and a growing community of developers advocate hybrid mobile apps development as a possible solution to mobile platforms fragmentation. Hybrid mobile apps are consistent across platforms and built on Web standards. In this paper, we present an empirical investigation into mobile hybrid apps. Our goal is to identify and analyse the traits and distinctions of publicly available hybrid mobile apps from end users’ perspective. The study has been conducted by mining 11,917 free apps and 3,041,315 reviews from the Google Play Store, and analyzing them from the end users’ perception perspective. The results of this study build an objective and reproducible snapshot about how hybrid mobile development is performing "in the wild" in real projects, thus establishing a base for future methods and techniques for developing hybrid mobile apps.</p>
  </span>
  
  <span class="bibtex hidden2">
    <p>@inproceedings{malavolta-ms-2015,
  author = {Malavolta, Ivano and Ruberto, Stefano and Soru, Tommaso and Terragni, Valerio},
  title = {End Users' Perception of Hybrid Mobile Apps in the Google Play Store},
  booktitle = {{IEEE} International Conference on Mobile Services},
  pages = {25-32},
  year = {2015},
  doi = {10.1109/MobServ.2015.14}
}
</p>
  </span>
</div>
</li>
</ol>


  </article>

  

  

</div>

      </div>
    </div>

    <footer>

  <div class="wrapper">
    © Copyright 2025 Valerio Terragni.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

    
  </div>

</footer>


    <!-- Load jQuery -->
<script src="//code.jquery.com/jquery-1.12.4.min.js"></script>

<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


<!-- Load KaTeX -->
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0/katex.min.js"></script>
<script src="/assets/js/katex.js"></script>




<!-- Include custom icon fonts -->
<link rel="stylesheet" href="/assets/css/fontawesome-all.min.css">
<link rel="stylesheet" href="/assets/css/academicons.min.css">


<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'G-VYCMDXQ2KX', 'auto');
ga('send', 'pageview');
</script>



  </body>

</html>
